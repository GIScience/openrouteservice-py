# coding: utf-8

"""
    Openrouteservice

    This is the openrouteservice API documentation for ORS Core-Version 7.1.0. Documentations for [older Core-Versions](https://github.com/GIScience/openrouteservice-docs/releases) can be rendered with the [Swagger-Editor](https://editor-next.swagger.io/).  # noqa: E501

    OpenAPI spec version: 7.1.0
    Contact: support@smartmobility.heigit.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openrouteservice.api_client import ApiClient


class GeocodeApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def geocode_autocomplete_get(self, text, **kwargs):  # noqa: E501
        """Geocode Autocomplete Service  # noqa: E501

        **Requests should be throttled when using this endpoint!** *Be aware that Responses are asynchronous.* Returns a JSON formatted list of objects corresponding to the search input. `boundary.*`-parameters can be combined if they are overlapping. **The interactivity for this enpoint is experimental!** [Please refer to this external Documentation](https://github.com/pelias/documentation/blob/master/autocomplete.md)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_autocomplete_get(text, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str text: Name of location, street address or postal code.  (required)
        :param float focus_point_lon: Longitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance.  Use with `focus.point.lat`. 
        :param float focus_point_lat: Latitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance. Use with `focus.point.lon`. 
        :param float boundary_rect_min_lon: Left border of rectangular boundary to narrow results. 
        :param float boundary_rect_min_lat: Bottom border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lon: Right border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lat: Top border of rectangular boundary to narrow results. 
        :param str boundary_country: Restrict results to single country. Possible values are [alpha-2 and alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1). Example: `DEU` or `DE` for Germany. 
        :param list[str] sources: Restrict your search to specific sources. Searches all sources by default. You can either use the normal or short name. Sources are [`openstreetmap(osm)`](http://www.openstreetmap.org/), [`openaddresses(oa)`](http://openaddresses.io/), [`whosonfirst(wof)`](https://whosonfirst.org/), [`geonames(gn)`](http://www.geonames.org/). 
        :param list[str] layers: Restrict search to layers (place type). By default all layers are searched.   layer|description|   ----|----|   `venue`|points of interest, businesses, things with walls|   `address`|places with a street address|   `street`|streets,roads,highways|   `neighbourhood`|social communities, neighbourhoods|   `borough`|a local administrative boundary, currently only used for New York City|   `localadmin`|local administrative boundaries|   `locality`|towns, hamlets, cities|   `county`|official governmental area; usually bigger than a locality, almost always smaller than a region|   `macrocounty`|a related group of counties. Mostly in Europe.|   `region`|states and provinces|   `macroregion`|a related group of regions. Mostly in Europe|   `country`|places that issue passports, nations, nation-states|   `coarse`|alias for simultaneously using all administrative layers (everything except `venue` and `address`)| 
        :return: GeocodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.geocode_autocomplete_get_with_http_info(text, **kwargs)  # noqa: E501
        else:
            (data) = self.geocode_autocomplete_get_with_http_info(text, **kwargs)  # noqa: E501
            return data

    def geocode_autocomplete_get_with_http_info(self, text, **kwargs):  # noqa: E501
        """Geocode Autocomplete Service  # noqa: E501

        **Requests should be throttled when using this endpoint!** *Be aware that Responses are asynchronous.* Returns a JSON formatted list of objects corresponding to the search input. `boundary.*`-parameters can be combined if they are overlapping. **The interactivity for this enpoint is experimental!** [Please refer to this external Documentation](https://github.com/pelias/documentation/blob/master/autocomplete.md)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_autocomplete_get_with_http_info(text, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str text: Name of location, street address or postal code.  (required)
        :param float focus_point_lon: Longitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance.  Use with `focus.point.lat`. 
        :param float focus_point_lat: Latitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance. Use with `focus.point.lon`. 
        :param float boundary_rect_min_lon: Left border of rectangular boundary to narrow results. 
        :param float boundary_rect_min_lat: Bottom border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lon: Right border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lat: Top border of rectangular boundary to narrow results. 
        :param str boundary_country: Restrict results to single country. Possible values are [alpha-2 and alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1). Example: `DEU` or `DE` for Germany. 
        :param list[str] sources: Restrict your search to specific sources. Searches all sources by default. You can either use the normal or short name. Sources are [`openstreetmap(osm)`](http://www.openstreetmap.org/), [`openaddresses(oa)`](http://openaddresses.io/), [`whosonfirst(wof)`](https://whosonfirst.org/), [`geonames(gn)`](http://www.geonames.org/). 
        :param list[str] layers: Restrict search to layers (place type). By default all layers are searched.   layer|description|   ----|----|   `venue`|points of interest, businesses, things with walls|   `address`|places with a street address|   `street`|streets,roads,highways|   `neighbourhood`|social communities, neighbourhoods|   `borough`|a local administrative boundary, currently only used for New York City|   `localadmin`|local administrative boundaries|   `locality`|towns, hamlets, cities|   `county`|official governmental area; usually bigger than a locality, almost always smaller than a region|   `macrocounty`|a related group of counties. Mostly in Europe.|   `region`|states and provinces|   `macroregion`|a related group of regions. Mostly in Europe|   `country`|places that issue passports, nations, nation-states|   `coarse`|alias for simultaneously using all administrative layers (everything except `venue` and `address`)| 
        :return: GeocodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['text', 'focus_point_lon', 'focus_point_lat', 'boundary_rect_min_lon', 'boundary_rect_min_lat', 'boundary_rect_max_lon', 'boundary_rect_max_lat', 'boundary_country', 'sources', 'layers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method geocode_autocomplete_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'text' is set
        if ('text' not in params or
                params['text'] is None):
            raise ValueError("Missing the required parameter `text` when calling `geocode_autocomplete_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501
        if 'focus_point_lon' in params:
            query_params.append(('focus.point.lon', params['focus_point_lon']))  # noqa: E501
        if 'focus_point_lat' in params:
            query_params.append(('focus.point.lat', params['focus_point_lat']))  # noqa: E501
        if 'boundary_rect_min_lon' in params:
            query_params.append(('boundary.rect.min_lon', params['boundary_rect_min_lon']))  # noqa: E501
        if 'boundary_rect_min_lat' in params:
            query_params.append(('boundary.rect.min_lat', params['boundary_rect_min_lat']))  # noqa: E501
        if 'boundary_rect_max_lon' in params:
            query_params.append(('boundary.rect.max_lon', params['boundary_rect_max_lon']))  # noqa: E501
        if 'boundary_rect_max_lat' in params:
            query_params.append(('boundary.rect.max_lat', params['boundary_rect_max_lat']))  # noqa: E501
        if 'boundary_country' in params:
            query_params.append(('boundary.country', params['boundary_country']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501
            collection_formats['sources'] = 'multi'  # noqa: E501
        if 'layers' in params:
            query_params.append(('layers', params['layers']))  # noqa: E501
            collection_formats['layers'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/geocode/autocomplete', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GeocodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def geocode_reverse_get(self, point_lon, point_lat, **kwargs):  # noqa: E501
        """Reverse Geocode Service  # noqa: E501

        Returns the next enclosing object with an address tag which surrounds the given coordinate. **The interactivity for this enpoint is experimental!** [Please refer to this external Documentation](https://github.com/pelias/documentation/blob/master/reverse.md#reverse-geocoding)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_reverse_get(point_lon, point_lat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float point_lon: Longitude of the coordinate to query.  (required)
        :param float point_lat: Latitude of the coordinate to query.  (required)
        :param float boundary_circle_radius: Restrict search to circular region around `point.lat/point.lon`. Value in kilometers. 
        :param int size: Set the number of returned results. 
        :param list[str] layers: Restrict search to layers (place type). By default all layers are searched.   layer|description|   ----|----|   `venue`|points of interest, businesses, things with walls|   `address`|places with a street address|   `street`|streets,roads,highways|   `neighbourhood`|social communities, neighbourhoods|   `locality`|towns, hamlets, cities|   `borough`|a local administrative boundary, currently only used for New York City|   `localadmin`|local administrative boundaries|   `county`|official governmental area; usually bigger than a locality, almost always smaller than a region|   `macrocounty`|a related group of counties. Mostly in Europe.|   `region`|states and provinces|   `macroregion`|a related group of regions. Mostly in Europe|   `country`|places that issue passports, nations, nation-states|   `coarse`|alias for simultaneously using all administrative layers (everything except `venue` and `address`)| 
        :param list[str] sources: Restrict your search to specific sources. Searches all sources by default. You can either use the normal or short name. Sources are [`openstreetmap(osm)`](http://www.openstreetmap.org/), [`openaddresses(oa)`](http://openaddresses.io/), [`whosonfirst(wof)`](https://whosonfirst.org/), [`geonames(gn)`](http://www.geonames.org/). 
        :param str boundary_country: Restrict search to country by [alpha 2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [alpha 3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) codes. 
        :return: GeocodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.geocode_reverse_get_with_http_info(point_lon, point_lat, **kwargs)  # noqa: E501
        else:
            (data) = self.geocode_reverse_get_with_http_info(point_lon, point_lat, **kwargs)  # noqa: E501
            return data

    def geocode_reverse_get_with_http_info(self, point_lon, point_lat, **kwargs):  # noqa: E501
        """Reverse Geocode Service  # noqa: E501

        Returns the next enclosing object with an address tag which surrounds the given coordinate. **The interactivity for this enpoint is experimental!** [Please refer to this external Documentation](https://github.com/pelias/documentation/blob/master/reverse.md#reverse-geocoding)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_reverse_get_with_http_info(point_lon, point_lat, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float point_lon: Longitude of the coordinate to query.  (required)
        :param float point_lat: Latitude of the coordinate to query.  (required)
        :param float boundary_circle_radius: Restrict search to circular region around `point.lat/point.lon`. Value in kilometers. 
        :param int size: Set the number of returned results. 
        :param list[str] layers: Restrict search to layers (place type). By default all layers are searched.   layer|description|   ----|----|   `venue`|points of interest, businesses, things with walls|   `address`|places with a street address|   `street`|streets,roads,highways|   `neighbourhood`|social communities, neighbourhoods|   `locality`|towns, hamlets, cities|   `borough`|a local administrative boundary, currently only used for New York City|   `localadmin`|local administrative boundaries|   `county`|official governmental area; usually bigger than a locality, almost always smaller than a region|   `macrocounty`|a related group of counties. Mostly in Europe.|   `region`|states and provinces|   `macroregion`|a related group of regions. Mostly in Europe|   `country`|places that issue passports, nations, nation-states|   `coarse`|alias for simultaneously using all administrative layers (everything except `venue` and `address`)| 
        :param list[str] sources: Restrict your search to specific sources. Searches all sources by default. You can either use the normal or short name. Sources are [`openstreetmap(osm)`](http://www.openstreetmap.org/), [`openaddresses(oa)`](http://openaddresses.io/), [`whosonfirst(wof)`](https://whosonfirst.org/), [`geonames(gn)`](http://www.geonames.org/). 
        :param str boundary_country: Restrict search to country by [alpha 2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [alpha 3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) codes. 
        :return: GeocodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['point_lon', 'point_lat', 'boundary_circle_radius', 'size', 'layers', 'sources', 'boundary_country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method geocode_reverse_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'point_lon' is set
        if ('point_lon' not in params or
                params['point_lon'] is None):
            raise ValueError("Missing the required parameter `point_lon` when calling `geocode_reverse_get`")  # noqa: E501
        # verify the required parameter 'point_lat' is set
        if ('point_lat' not in params or
                params['point_lat'] is None):
            raise ValueError("Missing the required parameter `point_lat` when calling `geocode_reverse_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'point_lon' in params:
            query_params.append(('point.lon', params['point_lon']))  # noqa: E501
        if 'point_lat' in params:
            query_params.append(('point.lat', params['point_lat']))  # noqa: E501
        if 'boundary_circle_radius' in params:
            query_params.append(('boundary.circle.radius', params['boundary_circle_radius']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'layers' in params:
            query_params.append(('layers', params['layers']))  # noqa: E501
            collection_formats['layers'] = 'multi'  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501
            collection_formats['sources'] = 'multi'  # noqa: E501
        if 'boundary_country' in params:
            query_params.append(('boundary.country', params['boundary_country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/geocode/reverse', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GeocodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def geocode_search_get(self, text, **kwargs):  # noqa: E501
        """Forward Geocode Service  # noqa: E501

        Returns a JSON formatted list of objects corresponding to the search input. `boundary.*`-parameters can be combined if they are overlapping. **The interactivity for this enpoint is experimental!** [Please refer to this external Documentation](https://github.com/pelias/documentation/blob/master/search.md#search-the-world)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_search_get(text, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str text: Name of location, street address or postal code.  (required)
        :param float focus_point_lon: Longitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance.  Use with `focus.point.lat`. 
        :param float focus_point_lat: Latitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance. Use with `focus.point.lon`. 
        :param float boundary_rect_min_lon: Left border of rectangular boundary to narrow results. 
        :param float boundary_rect_min_lat: Bottom border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lon: Right border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lat: Top border of rectangular boundary to narrow results. 
        :param float boundary_circle_lon: Center Longitude of circular boundary to narrow results. Use with `boundary.circle.lat` & `boundary.circle.radius`. 
        :param float boundary_circle_lat: Center Latitude of circular boundary to narrow results. Use with `boundary.circle.lon` & `boundary.circle.radius`. 
        :param float boundary_circle_radius: Radius of circular boundary around the center coordinate in kilometers. Use with `boundary.circle.lon` & `boundary.circle.lat`. 
        :param str boundary_gid: Restrict results to administrative boundary using a Pelias global id [`gid`](https://github.com/pelias/documentation/blob/f1f475aa4f8c18426fb80baea636990502c08ed3/search.md#search-within-a-parent-administrative-area). `gid`s for records can be found using either the [Who's on First Spelunker](http://spelunker.whosonfirst.org/), a tool for searching Who's on First data, or from the responses of other Pelias queries. In this case a [search for Oklahoma](http://pelias.github.io/compare/#/v1/search%3Ftext=oklahoma) will return the proper `gid`. 
        :param str boundary_country: Restrict results to single country. Possible values are [alpha-2 and alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1). Example: `DEU` or `DE` for Germany. 
        :param list[str] sources: Restrict your search to specific sources. Searches all sources by default. You can either use the normal or short name. Sources are [`openstreetmap(osm)`](http://www.openstreetmap.org/), [`openaddresses(oa)`](http://openaddresses.io/), [`whosonfirst(wof)`](https://whosonfirst.org/), [`geonames(gn)`](http://www.geonames.org/). 
        :param list[str] layers: Restrict search to layers (place type). By default all layers are searched.   layer|description|   ----|----|   `venue`|points of interest, businesses, things with walls|   `address`|places with a street address|   `street`|streets,roads,highways|   `neighbourhood`|social communities, neighbourhoods|   `borough`|a local administrative boundary, currently only used for New York City|   `localadmin`|local administrative boundaries|   `locality`|towns, hamlets, cities|   `county`|official governmental area; usually bigger than a locality, almost always smaller than a region|   `macrocounty`|a related group of counties. Mostly in Europe.|   `region`|states and provinces|   `macroregion`|a related group of regions. Mostly in Europe|   `country`|places that issue passports, nations, nation-states|   `coarse`|alias for simultaneously using all administrative layers (everything except `venue` and `address`)| 
        :param int size: Set the number of returned results. 
        :return: GeocodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.geocode_search_get_with_http_info(text, **kwargs)  # noqa: E501
        else:
            (data) = self.geocode_search_get_with_http_info(text, **kwargs)  # noqa: E501
            return data

    def geocode_search_get_with_http_info(self, text, **kwargs):  # noqa: E501
        """Forward Geocode Service  # noqa: E501

        Returns a JSON formatted list of objects corresponding to the search input. `boundary.*`-parameters can be combined if they are overlapping. **The interactivity for this enpoint is experimental!** [Please refer to this external Documentation](https://github.com/pelias/documentation/blob/master/search.md#search-the-world)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_search_get_with_http_info(text, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str text: Name of location, street address or postal code.  (required)
        :param float focus_point_lon: Longitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance.  Use with `focus.point.lat`. 
        :param float focus_point_lat: Latitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance. Use with `focus.point.lon`. 
        :param float boundary_rect_min_lon: Left border of rectangular boundary to narrow results. 
        :param float boundary_rect_min_lat: Bottom border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lon: Right border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lat: Top border of rectangular boundary to narrow results. 
        :param float boundary_circle_lon: Center Longitude of circular boundary to narrow results. Use with `boundary.circle.lat` & `boundary.circle.radius`. 
        :param float boundary_circle_lat: Center Latitude of circular boundary to narrow results. Use with `boundary.circle.lon` & `boundary.circle.radius`. 
        :param float boundary_circle_radius: Radius of circular boundary around the center coordinate in kilometers. Use with `boundary.circle.lon` & `boundary.circle.lat`. 
        :param str boundary_gid: Restrict results to administrative boundary using a Pelias global id [`gid`](https://github.com/pelias/documentation/blob/f1f475aa4f8c18426fb80baea636990502c08ed3/search.md#search-within-a-parent-administrative-area). `gid`s for records can be found using either the [Who's on First Spelunker](http://spelunker.whosonfirst.org/), a tool for searching Who's on First data, or from the responses of other Pelias queries. In this case a [search for Oklahoma](http://pelias.github.io/compare/#/v1/search%3Ftext=oklahoma) will return the proper `gid`. 
        :param str boundary_country: Restrict results to single country. Possible values are [alpha-2 and alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1). Example: `DEU` or `DE` for Germany. 
        :param list[str] sources: Restrict your search to specific sources. Searches all sources by default. You can either use the normal or short name. Sources are [`openstreetmap(osm)`](http://www.openstreetmap.org/), [`openaddresses(oa)`](http://openaddresses.io/), [`whosonfirst(wof)`](https://whosonfirst.org/), [`geonames(gn)`](http://www.geonames.org/). 
        :param list[str] layers: Restrict search to layers (place type). By default all layers are searched.   layer|description|   ----|----|   `venue`|points of interest, businesses, things with walls|   `address`|places with a street address|   `street`|streets,roads,highways|   `neighbourhood`|social communities, neighbourhoods|   `borough`|a local administrative boundary, currently only used for New York City|   `localadmin`|local administrative boundaries|   `locality`|towns, hamlets, cities|   `county`|official governmental area; usually bigger than a locality, almost always smaller than a region|   `macrocounty`|a related group of counties. Mostly in Europe.|   `region`|states and provinces|   `macroregion`|a related group of regions. Mostly in Europe|   `country`|places that issue passports, nations, nation-states|   `coarse`|alias for simultaneously using all administrative layers (everything except `venue` and `address`)| 
        :param int size: Set the number of returned results. 
        :return: GeocodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['text', 'focus_point_lon', 'focus_point_lat', 'boundary_rect_min_lon', 'boundary_rect_min_lat', 'boundary_rect_max_lon', 'boundary_rect_max_lat', 'boundary_circle_lon', 'boundary_circle_lat', 'boundary_circle_radius', 'boundary_gid', 'boundary_country', 'sources', 'layers', 'size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method geocode_search_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'text' is set
        if ('text' not in params or
                params['text'] is None):
            raise ValueError("Missing the required parameter `text` when calling `geocode_search_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501
        if 'focus_point_lon' in params:
            query_params.append(('focus.point.lon', params['focus_point_lon']))  # noqa: E501
        if 'focus_point_lat' in params:
            query_params.append(('focus.point.lat', params['focus_point_lat']))  # noqa: E501
        if 'boundary_rect_min_lon' in params:
            query_params.append(('boundary.rect.min_lon', params['boundary_rect_min_lon']))  # noqa: E501
        if 'boundary_rect_min_lat' in params:
            query_params.append(('boundary.rect.min_lat', params['boundary_rect_min_lat']))  # noqa: E501
        if 'boundary_rect_max_lon' in params:
            query_params.append(('boundary.rect.max_lon', params['boundary_rect_max_lon']))  # noqa: E501
        if 'boundary_rect_max_lat' in params:
            query_params.append(('boundary.rect.max_lat', params['boundary_rect_max_lat']))  # noqa: E501
        if 'boundary_circle_lon' in params:
            query_params.append(('boundary.circle.lon', params['boundary_circle_lon']))  # noqa: E501
        if 'boundary_circle_lat' in params:
            query_params.append(('boundary.circle.lat', params['boundary_circle_lat']))  # noqa: E501
        if 'boundary_circle_radius' in params:
            query_params.append(('boundary.circle.radius', params['boundary_circle_radius']))  # noqa: E501
        if 'boundary_gid' in params:
            query_params.append(('boundary.gid', params['boundary_gid']))  # noqa: E501
        if 'boundary_country' in params:
            query_params.append(('boundary.country', params['boundary_country']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501
            collection_formats['sources'] = 'multi'  # noqa: E501
        if 'layers' in params:
            query_params.append(('layers', params['layers']))  # noqa: E501
            collection_formats['layers'] = 'multi'  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/geocode/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GeocodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def geocode_search_structured_get(self, **kwargs):  # noqa: E501
        """Structured Forward Geocode Service (beta)  # noqa: E501

        Returns a JSON formatted list of objects corresponding to the search input. **The interactivity for this enpoint is experimental!** [Please refer to this external Documentation](https://github.com/pelias/documentation/blob/master/structured-geocoding.md#structured-geocoding)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_search_structured_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Search for full address with house number or only a street name. 
        :param str neighbourhood: Search for neighbourhoods. Neighbourhoods are vernacular geographic entities that may not necessarily be official administrative divisions but are important nonetheless. Example: `Notting Hill`. 
        :param str country: Search for full country name, [alpha 2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [alpha 3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) codes. 
        :param str postalcode: Search for postal codes. Postal codes are unique within a country so they are useful in geocoding as a shorthand for a fairly granular geographical location. 
        :param str region: Search for regions. Regions are normally the first-level administrative divisions within countries. For US-regions [common abbreviations](https://en.wikipedia.org/wiki/List_of_U.S._state_abbreviations) can be used. 
        :param str county: Search for counties. Counties are administrative divisions between localities and regions. Can be useful when attempting to disambiguate between localities. 
        :param str locality: Search for localities. Localities are equivalent to what are commonly referred to as *cities*. 
        :param str borough: Search for boroughs. Boroughs are mostly known in the context of New York City, even though they may exist in other cities, such as Mexico City. Example: `Manhatten`. 
        :param float focus_point_lon: Longitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance.  Use with `focus.point.lat`. 
        :param float focus_point_lat: Latitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance. Use with `focus.point.lon`. 
        :param float boundary_rect_min_lon: Left border of rectangular boundary to narrow results. 
        :param float boundary_rect_min_lat: Bottom border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lon: Right border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lat: Top border of rectangular boundary to narrow results. 
        :param float boundary_circle_lon: Center Longitude of circular boundary to narrow results. Use with `boundary.circle.lat` & `boundary.circle.radius`. 
        :param float boundary_circle_lat: Center Latitude of circular boundary to narrow results. Use with `boundary.circle.lon` & `boundary.circle.radius`. 
        :param float boundary_circle_radius: Radius of circular boundary around the center coordinate in kilometers. Use with `boundary.circle.lon` & `boundary.circle.lat`. 
        :param str boundary_country: Restrict results to single country. Possible values are [alpha-2 and alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1). Example: `DEU` or `DE` for Germany. 
        :param list[str] layers: Restrict search to layers (place type). By default all layers are searched.   layer|description|   ----|----|   `venue`|points of interest, businesses, things with walls|   `address`|places with a street address|   `street`|streets,roads,highways|   `neighbourhood`|social communities, neighbourhoods|   `borough`|a local administrative boundary, currently only used for New York City|   `localadmin`|local administrative boundaries|   `locality`|towns, hamlets, cities|   `county`|official governmental area; usually bigger than a locality, almost always smaller than a region|   `macrocounty`|a related group of counties. Mostly in Europe.|   `region`|states and provinces|   `macroregion`|a related group of regions. Mostly in Europe|   `country`|places that issue passports, nations, nation-states|   `coarse`|alias for simultaneously using all administrative layers (everything except `venue` and `address`)| 
        :param list[str] sources: Restrict your search to specific sources. Searches all sources by default. You can either use the normal or short name. Sources are [`openstreetmap(osm)`](http://www.openstreetmap.org/), [`openaddresses(oa)`](http://openaddresses.io/), [`whosonfirst(wof)`](https://whosonfirst.org/), [`geonames(gn)`](http://www.geonames.org/). 
        :param int size: Set the number of returned results. 
        :return: GeocodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.geocode_search_structured_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.geocode_search_structured_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def geocode_search_structured_get_with_http_info(self, **kwargs):  # noqa: E501
        """Structured Forward Geocode Service (beta)  # noqa: E501

        Returns a JSON formatted list of objects corresponding to the search input. **The interactivity for this enpoint is experimental!** [Please refer to this external Documentation](https://github.com/pelias/documentation/blob/master/structured-geocoding.md#structured-geocoding)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geocode_search_structured_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Search for full address with house number or only a street name. 
        :param str neighbourhood: Search for neighbourhoods. Neighbourhoods are vernacular geographic entities that may not necessarily be official administrative divisions but are important nonetheless. Example: `Notting Hill`. 
        :param str country: Search for full country name, [alpha 2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) or [alpha 3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) codes. 
        :param str postalcode: Search for postal codes. Postal codes are unique within a country so they are useful in geocoding as a shorthand for a fairly granular geographical location. 
        :param str region: Search for regions. Regions are normally the first-level administrative divisions within countries. For US-regions [common abbreviations](https://en.wikipedia.org/wiki/List_of_U.S._state_abbreviations) can be used. 
        :param str county: Search for counties. Counties are administrative divisions between localities and regions. Can be useful when attempting to disambiguate between localities. 
        :param str locality: Search for localities. Localities are equivalent to what are commonly referred to as *cities*. 
        :param str borough: Search for boroughs. Boroughs are mostly known in the context of New York City, even though they may exist in other cities, such as Mexico City. Example: `Manhatten`. 
        :param float focus_point_lon: Longitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance.  Use with `focus.point.lat`. 
        :param float focus_point_lat: Latitude of the `focus.point`. Specify the focus point to order results by linear distance to this point. Works for up to 100 kilometers distance. Use with `focus.point.lon`. 
        :param float boundary_rect_min_lon: Left border of rectangular boundary to narrow results. 
        :param float boundary_rect_min_lat: Bottom border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lon: Right border of rectangular boundary to narrow results. 
        :param float boundary_rect_max_lat: Top border of rectangular boundary to narrow results. 
        :param float boundary_circle_lon: Center Longitude of circular boundary to narrow results. Use with `boundary.circle.lat` & `boundary.circle.radius`. 
        :param float boundary_circle_lat: Center Latitude of circular boundary to narrow results. Use with `boundary.circle.lon` & `boundary.circle.radius`. 
        :param float boundary_circle_radius: Radius of circular boundary around the center coordinate in kilometers. Use with `boundary.circle.lon` & `boundary.circle.lat`. 
        :param str boundary_country: Restrict results to single country. Possible values are [alpha-2 and alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1). Example: `DEU` or `DE` for Germany. 
        :param list[str] layers: Restrict search to layers (place type). By default all layers are searched.   layer|description|   ----|----|   `venue`|points of interest, businesses, things with walls|   `address`|places with a street address|   `street`|streets,roads,highways|   `neighbourhood`|social communities, neighbourhoods|   `borough`|a local administrative boundary, currently only used for New York City|   `localadmin`|local administrative boundaries|   `locality`|towns, hamlets, cities|   `county`|official governmental area; usually bigger than a locality, almost always smaller than a region|   `macrocounty`|a related group of counties. Mostly in Europe.|   `region`|states and provinces|   `macroregion`|a related group of regions. Mostly in Europe|   `country`|places that issue passports, nations, nation-states|   `coarse`|alias for simultaneously using all administrative layers (everything except `venue` and `address`)| 
        :param list[str] sources: Restrict your search to specific sources. Searches all sources by default. You can either use the normal or short name. Sources are [`openstreetmap(osm)`](http://www.openstreetmap.org/), [`openaddresses(oa)`](http://openaddresses.io/), [`whosonfirst(wof)`](https://whosonfirst.org/), [`geonames(gn)`](http://www.geonames.org/). 
        :param int size: Set the number of returned results. 
        :return: GeocodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'neighbourhood', 'country', 'postalcode', 'region', 'county', 'locality', 'borough', 'focus_point_lon', 'focus_point_lat', 'boundary_rect_min_lon', 'boundary_rect_min_lat', 'boundary_rect_max_lon', 'boundary_rect_max_lat', 'boundary_circle_lon', 'boundary_circle_lat', 'boundary_circle_radius', 'boundary_country', 'layers', 'sources', 'size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method geocode_search_structured_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501
        if 'neighbourhood' in params:
            query_params.append(('neighbourhood', params['neighbourhood']))  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
        if 'postalcode' in params:
            query_params.append(('postalcode', params['postalcode']))  # noqa: E501
        if 'region' in params:
            query_params.append(('region', params['region']))  # noqa: E501
        if 'county' in params:
            query_params.append(('county', params['county']))  # noqa: E501
        if 'locality' in params:
            query_params.append(('locality', params['locality']))  # noqa: E501
        if 'borough' in params:
            query_params.append(('borough', params['borough']))  # noqa: E501
        if 'focus_point_lon' in params:
            query_params.append(('focus.point.lon', params['focus_point_lon']))  # noqa: E501
        if 'focus_point_lat' in params:
            query_params.append(('focus.point.lat', params['focus_point_lat']))  # noqa: E501
        if 'boundary_rect_min_lon' in params:
            query_params.append(('boundary.rect.min_lon', params['boundary_rect_min_lon']))  # noqa: E501
        if 'boundary_rect_min_lat' in params:
            query_params.append(('boundary.rect.min_lat', params['boundary_rect_min_lat']))  # noqa: E501
        if 'boundary_rect_max_lon' in params:
            query_params.append(('boundary.rect.max_lon', params['boundary_rect_max_lon']))  # noqa: E501
        if 'boundary_rect_max_lat' in params:
            query_params.append(('boundary.rect.max_lat', params['boundary_rect_max_lat']))  # noqa: E501
        if 'boundary_circle_lon' in params:
            query_params.append(('boundary.circle.lon', params['boundary_circle_lon']))  # noqa: E501
        if 'boundary_circle_lat' in params:
            query_params.append(('boundary.circle.lat', params['boundary_circle_lat']))  # noqa: E501
        if 'boundary_circle_radius' in params:
            query_params.append(('boundary.circle.radius', params['boundary_circle_radius']))  # noqa: E501
        if 'boundary_country' in params:
            query_params.append(('boundary.country', params['boundary_country']))  # noqa: E501
        if 'layers' in params:
            query_params.append(('layers', params['layers']))  # noqa: E501
            collection_formats['layers'] = 'multi'  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501
            collection_formats['sources'] = 'multi'  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/geocode/search/structured', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GeocodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
